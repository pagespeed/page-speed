// Copyright 2009 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "pagespeed/rules/enable_gzip_compression.h"

#include <string>

#include "base/logging.h"
#include "base/string_util.h"
#include "pagespeed/core/resource.h"
#include "pagespeed/core/resource_util.h"
#include "pagespeed/core/result_provider.h"
#include "pagespeed/l10n/l10n.h"
#include "pagespeed/proto/pagespeed_output.pb.h"
#ifdef USE_SYSTEM_ZLIB
#include "zlib.h"
#else
#include "third_party/zlib/zlib.h"
#endif

namespace {

// Minimum number of bytes before it's typically a win to apply gzip
// to a resource. Below this size, the cost of gzip overhead typically
// outweighs the benefits of gzip compression (i.e. the compressed
// resource is larger than the uncompressed resource).
const size_t kMinGzipSize = 150;

}  // namespace

namespace pagespeed {

namespace rules {

namespace {

class GzipMinifier : public Minifier {
 public:
  explicit GzipMinifier(SavingsComputer* computer) : computer_(computer) {
    DCHECK(NULL != computer) << "SavingsComputer must be non-null.";
  }

  // Minifier interface:
  virtual const char* name() const;
  virtual UserFacingString header_format() const;
  virtual const char* documentation_url() const;
  virtual UserFacingString body_format() const;
  virtual UserFacingString child_format() const;
  virtual const MinifierOutput* Minify(const Resource& resource) const;

 private:
  bool IsCompressed(const Resource& resource) const;
  bool IsViolation(const Resource& resource) const;

  scoped_ptr<SavingsComputer> computer_;

  DISALLOW_COPY_AND_ASSIGN(GzipMinifier);
};

const char* GzipMinifier::name() const {
  return "EnableGzipCompression";
}

UserFacingString GzipMinifier::header_format() const {
  // TRANSLATOR: The name of a Page Speed rule that tells webmasters to enable
  // gzip compression on their servers (i.e. enable compressing the web content
  // before it is sent to clients).  This appears in a list of rule names
  // generated by Page Speed, telling webmasters which rules they broke in their
  // website.
  return _("Enable compression");
}

const char* GzipMinifier::documentation_url() const {
  return "payload.html#GzipCompression";
}

UserFacingString GzipMinifier::body_format() const {
  // TRANSLATOR: Descriptive header for a list of URLs that were served
  // uncompressed, in violation of the EnableGzipCompression rule.  It tells the
  // webmaster that compressing all of those resources could reduce the amount
  // of data transferred (which would speed up the site).  It is followed by a
  // list of uncompressed resource URLs.  "$1" is a format token that will be
  // replaced by the amount of data transferred saved by compressing (in bytes)
  // (e.g. "32.5KiB").  "$2" will be replaced by the percentage saved by
  // compressing (e.g. "25").
  return _("Compressing the following resources with gzip could reduce their "
           "transfer size by $1 ($2% reduction).");
}

UserFacingString GzipMinifier::child_format() const {
  // TRANSLATOR: Description of a single resource that was served uncompressed,
  // in violation of the EnableGzipCompression rule.  It gives the URL of the
  // resource, as well as the amount of data that would be saved by compressing.
  // It appears in a list of all the uncompressed resources on a site.  "$1" is
  // a format token that will be replaced with the URL of the uncompressed
  // resource in question.  "$2" will be replaced with the amount of data
  // transferred saved by compressing (in bytes) (e.g. "32.5KiB").  "$3" will be
  // replaced with the percentage of data transferred saved by compressing.
  return _("Compressing $1 could save $2 ($3% reduction).");
}

const MinifierOutput* GzipMinifier::Minify(const Resource& resource) const {
  if (!computer_.get())
    return NULL;

  if (!IsViolation(resource)) {
    return new MinifierOutput();
  }
  Savings savings;
  if (computer_->ComputeSavings(resource, &savings)) {
    return new MinifierOutput(savings.response_bytes_saved());
  } else {
    return NULL; // error
  }
}

bool GzipMinifier::IsCompressed(const Resource& resource) const {
  const std::string& encoding = resource.GetResponseHeader("Content-Encoding");

  // HTTP allows Content-Encodings to be "stacked" in which case they
  // are comma-separated. Instead of splitting on commas and checking
  // each token, we just see if a valid known encoding appears in the
  // header, and if so, assume that encoding was applied to the
  // response.
  return encoding.find("gzip") != std::string::npos ||
      encoding.find("deflate") != std::string::npos;
}

bool GzipMinifier::IsViolation(const Resource& resource) const {
  return (!IsCompressed(resource) &&
          resource_util::IsCompressibleResource(resource) &&
          resource.GetResponseBody().size() >= kMinGzipSize);
}

class EnableCompressionScoreComputer : public CostBasedScoreComputer {
 public:
  EnableCompressionScoreComputer(const RuleResults* results,
                                 int64 max_possible_cost);
  virtual ~EnableCompressionScoreComputer();

 protected:
  virtual int64 ComputeCost();

 private:
  const RuleResults* const results_;
};

EnableCompressionScoreComputer::EnableCompressionScoreComputer(
    const RuleResults* results, int64 max_possible_cost)
    : CostBasedScoreComputer(max_possible_cost),
      results_(results) {
}

EnableCompressionScoreComputer::~EnableCompressionScoreComputer() {}

int64 EnableCompressionScoreComputer::ComputeCost() {
  int64 total_cost = 0;
  for (int idx = 0, end = results_->results_size(); idx < end; ++idx) {
    const Result& result = results_->results(idx);
    total_cost += result.original_response_bytes();
  }

  return total_cost;
}

}  // namespace

EnableGzipCompression::EnableGzipCompression(SavingsComputer* computer)
    : MinifyRule(new GzipMinifier(computer)) {}

int EnableGzipCompression::ComputeScore(const InputInformation& input_info,
                                        const RuleResults& results) {
  EnableCompressionScoreComputer score_computer(
      &results, resource_util::ComputeCompressibleResponseBytes(input_info));
  return score_computer.ComputeScore();
}

namespace compression_computer {

bool ZlibComputer::ComputeSavings(const pagespeed::Resource& resource,
                                  pagespeed::Savings* savings) {
  z_stream c_stream; /* compression stream */
  c_stream.zalloc = (alloc_func)0;
  c_stream.zfree = (free_func)0;
  c_stream.opaque = (voidpf)0;

  int err = deflateInit2(
      &c_stream,
      Z_DEFAULT_COMPRESSION,
      Z_DEFLATED,
      31,  // window size of 15, plus 16 for gzip
      8,   // default mem level (no zlib constant exists for this value)
      Z_DEFAULT_STRATEGY);
  if (err != Z_OK) {
    LOG(INFO) << "Failed to deflateInit2: " << err;
    return false;
  }

  c_stream.next_in = reinterpret_cast<Bytef*>(
      const_cast<char*>(resource.GetResponseBody().data()));
  c_stream.avail_in = resource.GetResponseBody().size();

  int compressed_size = 0;
  bool result = GetCompressedSize(&c_stream, &compressed_size);

  // clean up.
  err = deflateEnd(&c_stream);
  if (err != Z_OK) {
    LOG(INFO) << "Failed to deflateEnd: " << err;
    return false;
  }

  savings->set_response_bytes_saved(
      resource.GetResponseBody().size() - compressed_size);
  return result;
}

bool ZlibComputer::GetCompressedSize(z_stream* c_stream, int* compressed_size) {
  scoped_array<char> buffer(new char[kBufferSize]);

  int err = Z_OK;
  bool finished = false;

  while (!finished) {
    c_stream->next_out = reinterpret_cast<Bytef*>(buffer.get());
    c_stream->avail_out = kBufferSize;
    err = deflate(c_stream, Z_FINISH);

    switch (err) {
      case Z_OK:
        break;

      case Z_STREAM_END:
        finished = true;
        break;

      default:
        LOG(INFO) << "GetCompressedSize encountered error: " << err;
        return false;
    }

    *compressed_size += (kBufferSize - c_stream->avail_out);
  }

  const bool success = (err == Z_STREAM_END);
  if (!success) {
    LOG(INFO) << "GetCompressedSize expected Z_STREAM_END, got " << err;
  }
  return success;
}

}  // namespace compression_computer

}  // namespace rules

}  // namespace pagespeed
